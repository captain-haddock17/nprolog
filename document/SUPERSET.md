# Superset
 N-Prolog is compatible with ARITY/PROLOG. This is an old language specification from the 1980s. Some predicates have been added to run more modern code, primarily based on ISO-Prolog. However, please note that these may not necessarily conform to the ISO-Prolog specification.

 # Spec
The following extension functions respect ISO-Prolog as much as possible, but they are provided primarily for the purpose of being a backward-compatible extension in N-Prolog. Please refrain from pointing out differences with ISO-Prolog.


- \+ (not)

- atom_concat/3  
 The first and second arguments are concatenated and unified with the third argument. Now ,the following cases are not supported. e.g. atom_concat(X,b,ab).

- append/3

- member/2

- between/3

- select/3

- succ/2

- maplist/2

- compound/1

- ground/1

- once/1

- atom_codes/2

- atom_chars/2

- char_code/2

- number_codes/2

- number_chars/2

- predicate_property/2

- bagof/3

- setof/3

- findall/3

- write_canonical/1 /2

- atom_length/2

- get_code/1 2

- get_char/1 2

- get_byte/1 2

- put_char/1 2

- put_code/1 2

- put_byte/1 2

- peek_code/1 2

- peek_char/1 2

- peek_byte/1 2

- flush_output/0 1

- catch/3

- throw/1

- unify_with_occurs_check/2

- current_input/1

- current_output/1

- set_input/1

- set_output/1

- use_module/1

- module/1

- copy_term/2

- at_end_of_stream/1

- stream_property/2

- dynamic/1
In N-Prolog, when foo/1 is given, the entire foo predicate is defined as dynamic.

# Not ISO-Prolog
N-Prolog is specialized for experimenting with and playing around with small-scale code. Therefore, the following features are not included.

- sub_atom/5  
 Reverse computation is too complex.
- open/3  
 Please use open/3 compatible with Arity/Prolog.
- multifile/1 
 For now, we are not considering complex libraries.
- initialization/1 
- include/1
- ensure_loaded/1

- set_prolog_flag/2
 I cannot agree with dynamically changing specifications that are fundamental to the language, such as those related to strings.
- current_prolog_flag/2
- long atom with '\\' 
 Excessively long atoms hinder code readability.



# Module
A module is generated by module/2. The first argument is the module name, and the second argument is a list of predicates and their arities to be exported. Each file corresponds to one module. Files are stored in the library folder, and the filename is the module name followed by the .pl extension. To invoke a module, use use_module/1. The argument is an atom representing the module name.Predicates other than those exported have the module name prefixed to them.Predicates within a module are not displayed by listing/0.

e.g. 

```
:- module(asdf,[bar/1]).

bar(X) :- boo(X).

boo(X) :- write(X).

save file to library as asdf.pl
       |
       v
use_module(asdf)
bar(X) :-
    asdf_boo(X).
asdf_boo(X) :-
    write(X).

```


# String
In ARITY/PROLOG, strings were enclosed in $ symbols. In N-Prolog, this convention is maintained, but strings enclosed in double quotes (") are also recognized as strings. However, similar to ISO-Prolog, these are treated as lists.

```
N-Prolog Ver 3.80
?- X = "abc".
X = [97,98,99] .
yes
?- 

```

# Function
In ARITY/PROLOG, the ^ symbol is used for exponentiation. However, since ** is used for exponentiation in ISO-Prolog, we allow this as well.

```
N-Prolog Ver 3.80
?- X is 2**3.
X = 8 .
yes
?- 
```

# TCP/IP 
 I have implemented the TCP/IP predicates. see ./tests/socket.pl

- create_server_socket(Soket,port) 
 Creates and returns a socket as a server based on the port number. Provide the port number to port. It ranges from 0 to 65536.

- create_client-socket(Soket,port,ip-address)
 Provide the port number to port. It ranges from 0 to 65536. ip-address is given as an atom. Example: '127.1.1.1' Returns yes is success.

- send_socket(Socket,Atom) 
 Sends an atom to the socket. Returns yes.

- recv_socket(Socket,Atom) 
 Receives from the socket and returns yes.

- close_socket(Socket) 
 Closes the socket. Returns yes.

 ```
 start_server :-
    create_server_socket(ServerSocket, 5000),
    write('Server started on port 5000'),nl,
    recv_socket(ServerSocket, Message),
    write('Server received: '),
    write(Message),nl,
    send_socket(ServerSocket, Message),
    close_socket(ServerSocket).

start_client :-
    create_client_socket(ClientSocket, 5000, '127.1.1.1'),
    send_socket(ClientSocket, hello),
    write('Client sent: hello'),nl,
    recv_socket(ClientSocket, Message),
    write('Client recv: '),
    write(Message),nl,
    close_socket(ClientSocket).

 ```


# My Personal Thoughts on ISO-Prolog
I believe ISO-Prolog has excessively high requirements. It sets overly detailed specifications regarding syntax and imposes high standards on op/3. The appeal of Prolog, in my opinion, lies in the astonishing realization that first-order predicate logic can be applied to programming. I think overly detailed syntax rules hinder the widespread adoption of Prolog. I would like to emphasize that this is my personal opinion.